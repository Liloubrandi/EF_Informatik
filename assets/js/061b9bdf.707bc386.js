"use strict";(self.webpackChunkef_website_template=self.webpackChunkef_website_template||[]).push([[846],{7384:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"/Numtrip_blog","metadata":{"permalink":"/EF_Informatik/Numtrip_blog","editUrl":"https://github.com/Liloubrandi/EF_Informatik/tree/main/blog/Numtrip_blog.md","source":"@site/blog/Numtrip_blog.md","title":"Mein Weg zum Numtrip-Game","description":"Eingabe und Start:","date":"2023-01-23T18:27:13.000Z","formattedDate":"23. Januar 2023","tags":[],"readingTime":3.135,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"nextItem":{"title":"Wiedereinstieg in Python","permalink":"/EF_Informatik/2022/08/26/Wiedereinstieg-in-Python"}},"content":"### **Eingabe und Start:**\\n\\n- Als erstes musste ich irgendwie nach einer Eingabe nach Zeilen- und Spaltennummer fragen. Daf\xfcr habe ich eine Funktion \\"eingabe()\\" geschrieben, in der ich nach den beiden Zahlen frage. Die Eingabe wird noch validiert.\\n\\n```py\\ndef eingabe():\\n    zeile = input(\'Gib eine Zeilennummer zwischen 1 und 6 ein:\')\\n    spalte = input(\'Gib eine Spaltennummer zwischen 1 und 6 ein:\')\\n    eingabe_validieren(zeile, spalte)\\n    return (zeile, spalte)\\n```\\n\\nObiger Code funktioniert so noch nicht genau, war bloss erster Versuch, L\xf6sung weiter unten im Blog bei Validierung.\\n\\n!!! WICHTIG: Ich muss die Zahlen zur\xfcckgeben, damit sie weiterverwendet werden k\xf6nnen.\\n\\n- Dann habe ich eine neue Funktion \\"auswerten()\\" erstellt, die die Koordiaten liest und im Spielfeld sucht. Das gefundene Feld wird mit 0 markiert, was bei der \\"mache_spielfeld\\"-Funktion dazu f\xfchrt, dass das Feld leer ausgegeben wird.\\n\\n```py\\ndef auswerten(zeile, spalte):\\n    spielfeld[zeile][spalte] = 0\\n```\\n\\n!!! WICHTIG: Die Zahlen m\xfcssen an Variablen \xfcbergeben werden, die dann als zeile und spalte Parameter an die Funktion \\"auswerten()\\" \xfcbergeben werden kann. Dies geschieht in eingabe_validieren()\\"\\n\\n```py\\n    x, y = eingabe()\\n    auswerten(x, y)\\n```\\n\\n- Als letztes habe ich alle diese Funktionen in eine gesamte Funktion \\"play()\\" hineingeschrieben und diesen Vorgang solange das Spiel l\xe4uft (momentan unendlich lange) laufen lassen.\\n\\n### **Validierung: (2.12.22)**\\n\\n- Ich habe mit Alice sehr viel besprochen. Bei mir waren Probleme beim Validieren aufgetreten, da ich die Werte falsch oder als String \xfcbergeben habe. Bei ihr wurde das Wort \\"True\\" \xfcbergeben. Beides konten wir jedoch beheben.\\n\\n```py\\ndef eingabe_validieren(zeile, spalte):\\n    try:\\n        zeile = int(zeile) - 1\\n        spalte = int(spalte) - 1\\n        return True\\n    except:\\n        print(\'Zeilen- und Spaltennummer m\xfcssen Zahlen sein!\')\\n        return False\\n```\\n\\n??? Aufgetauchte Fragen: Muss hier \'return True\' geschrieben werden? Wird hier zeile und spalte \xfcbergeben?\\n\\n```py\\ndef eingabe():\\n    zeile = \\" \\"\\n    spalte = \\" \\"\\n    while not eingabe_validieren(zeile, spalte):\\n        zeile = input(\'Gib eine Zeilennummer zwischen 1 und 6 ein:\')\\n        spalte = input(\'Gib eine Spaltennummer zwischen 1 und 6 ein:\')\\n    return (int(zeile), int(spalte))\\n```\\n\\n!!! WICHTIG: Die Zahlen m\xfcssen noch einmal mit int() in Zahlen verwandelt werden, weil bei der Validierung bloss geschaut wird, ob es m\xf6glich w\xe4re, diese in Zahlen umzuwandeln.\\n\\n### **Nachbarzellen kombinieren**\\n\\n- Ich habe versucht den Floodfill-code so umzuwandeln, dass er in mein Spiel passt.\\n\\n??? Leider ist ein kleines Problem aufgetreten. Da ich die Zahl bereits vorher auf 0 gesetzt hatte und es also testet, ob diese Zahl (also 0) eine 2 ist - was ja nie der Fall sein wird.\\n\\n```py\\ndef nachbarfelder_l\xf6schen(x, y, vorherige_Zahl):\\n    if spielfeld[x][y] == vorherige_Zahl:  # Zahl ist ja bereits 0??\\n        spielfeld[x][y] = 0\\n        nachbarfelder_l\xf6schen(x, y + 1)  # rechts\\n        nachbarfelder_l\xf6schen(x, y - 1)  # links\\n        nachbarfelder_l\xf6schen(x + 1, y)  # unten\\n        nachbarfelder_l\xf6schen(x - 1, y)  # oben\\n```\\n\\n???Ausserdem wird nur die Zahl 2 getestet und nicht die Zahl, die vorher im Kasten stand - ich weiss nicht wie ich diese \xfcbergeben soll.\\n\\n```py\\nnachbarfelder_l\xf6schen(zeile, spalte, 2)\\n```\\n\\n- Die Probleme habe ich nun behoben, indem ich die Funktion auswerten ganz weggenommen habe (und somit die Zahl erst im \\"nachbarfelder_kombinieren\\" auf 0 gesetzt wird.) und die Funktion \\"nachbarfelder_komninieren\\" als Ganzes in \\"auswerten()\\" umgewandelt habe. Zus\xe4tzlich habe ich eine Zahl vorher \xfcbergeben, welche die Zahl in diesem Feld speichert und bei der rekursiven Auswerten-funktion benutzt werden kann. Damit es keine Fehler gibt, habe ich die Rahmenbedingung in den Code eingebaut.\\n\\n```py\\ndef auswerten(x, y, vorherige_Zahl):\\n    # Rahmenbedingungen\\n    if x < 0 or x > 4:\\n        return False\\n    if y < 0 or y > 4:\\n        return False\\n    # Feld\xfcberpr\xfcfen\\n    # im Spielfeld die richtige Liste (zeile), dann richtige Position in Liste (spalte)\\n    if spielfeld[x][y] == vorherige_Zahl:\\n        spielfeld[x][y] = 0\\n        auswerten(x, y + 1, vorherige_Zahl)  # rechts\\n        auswerten(x, y - 1, vorherige_Zahl)  # links\\n        auswerten(x + 1, y, vorherige_Zahl)  # unten\\n        auswerten(x - 1, y, vorherige_Zahl)  # oben\\n```"},{"id":"/2022/08/26/Wiedereinstieg-in-Python","metadata":{"permalink":"/EF_Informatik/2022/08/26/Wiedereinstieg-in-Python","editUrl":"https://github.com/Liloubrandi/EF_Informatik/tree/main/blog/2022-08-26-Wiedereinstieg-in-Python.md","source":"@site/blog/2022-08-26-Wiedereinstieg-in-Python.md","title":"Wiedereinstieg in Python","description":"---","date":"2022-08-26T00:00:00.000Z","formattedDate":"26. August 2022","tags":[],"readingTime":1.305,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"Mein Weg zum Numtrip-Game","permalink":"/EF_Informatik/Numtrip_blog"}},"content":"---\\n\\n### Mein pers\xf6nlicher Einstieg:\\n\\nIch habe vorher noch nie mit der Bibliothek \'turtle\' gearbeitet, deshalb kam mir (ausser viellicht die Struktur) fast nichts bekannt vor. Es war jedoch sehr selbsterkl\xe4rend und deswegen konnte ich gut den Anschluss finden.  \\n.\\n\\n### Meine Fehler:\\n\\nObwohl ich diesen Fehler bereits begangen habe, habe ich immer vergessen die **Anf\xfchrungszeichen** bei den **Farben** in der Klammer hinzuzuf\xfcgen.\\n\\n```py\\nfrom turtle import *\\n\\npencolor(\'red\')\\npensize(5)\\nforward(30)\\nright(90)\\n```\\n\\nWenn man in einem If etwas mitem einem Gleichzeichen vergleichen will, muss man immer ein Doppelgleich (==) setzen. Ein = w\xe4re eine Zuweisung bei einer Variable.\\n\\n```py\\nif i == 3:\\n    sechseck(100-10*i,\'green\')\\n#Dies ist nur ein Ausschnitt aus Codeblock\\n```\\n\\nIch habe erst nach dem dritten Mal lesen gemerkt, dass ich bei der Aufgabe mit der Stadt nicht \'pencolor(choice([1,3,5,7,9]))\' schreiben muss, sondern die Farbnahmen auflisten muss haha:/  \\n.\\n\\n### Das war mir besonders neu:\\n\\nDas man sequenzieren kann mit \'for i in range(n)\'\\n\\n```py\\nfrom turtle import *\\n\\nfor i in range(4))\\n    left(90)\\n    forward(80)\\n```\\n\\n.\\n\\n### Fragen, die aufgetaucht sind zu \xdcbungen:\\n\\nKann man Kreise (circle(x,y)) nur nach links machen oder auch der andere Weg?\\n\\n```py\\nblume()\\nright(40)\\npencolor(\'black\')\\npensize(2)\\nfor i in range(20):\\n    forward(10)\\n    right(2)\\n#nicht richtiges Codebeispiel, nur Auschnitt aus dem Code mit meiner L\xf6sung (anstatt mit den circle-Funktionsaufruf)\\n```\\n\\nKann Python auch hochrechnen mit Hochzeichen (^) anstatt nur mit x \\\\* x?\\n\\n```py\\nleft(135)\\n    forward(sqrt(size * size + size * size))\\n    left(90)\\n    forward(sqrt(size * size + size * size)/2)\\n#nur Ausschnitt aus Codeblock\\n```\\n\\nWie mache ich beim Ratespiel die M\xf6glichkeit das Ganze abzubrechen?"}]}')}}]);
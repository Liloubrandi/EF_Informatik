"use strict";(self.webpackChunkef_website_template=self.webpackChunkef_website_template||[]).push([[846],{7384:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"/Numtrip_blog","metadata":{"permalink":"/EF_Informatik/Numtrip_blog","editUrl":"https://github.com/Liloubrandi/EF_Informatik/tree/main/blog/Numtrip_blog.md","source":"@site/blog/Numtrip_blog.md","title":"Mein Weg zum Numtrip-Game","description":"Eingabe und Start:","date":"2023-06-15T14:59:07.000Z","formattedDate":"15. Juni 2023","tags":[],"readingTime":7.395,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"nextItem":{"title":"Numtrip_finaler_blog","permalink":"/EF_Informatik/Numtrip_finaler_blog"}},"content":"### **Eingabe und Start:**\\n\\n- Als erstes musste ich irgendwie nach einer Eingabe nach Zeilen- und Spaltennummer fragen. Daf\xfcr habe ich eine Funktion \\"eingabe()\\" geschrieben, in der ich nach den beiden Zahlen frage. Die Eingabe wird noch validiert. Damit ich nun so lange frage, bis die Eingabe valide ist, verwende ich eine while-Schlaufe.\\n\\n```py\\ndef eingabe():\\n    # invalide Eingaben, damit der Code unter while \xfcberhaupt durchgef\xfchrt wird.\\n    valid = False\\n    while not valid:\\n        zeile = input(\'Gib eine Zeilennummer zwischen 1 und 5 ein:\')\\n        spalte = input(\'Gib eine Spaltennummer zwischen 1 und 5 ein:\')\\n        if eingabe_validieren(zeile, spalte) and feldauswahl_validieren(zeile, spalte):\\n            valid = True\\n    # noch einmal, weil bei eingabe_validieren \xfcberpr\xfcft es nur\\n    return (int(zeile) - 1, int(spalte) - 1)\\n```\\n\\n!!! WICHTIG: Ich muss die Zahlen zur\xfcckgeben, damit sie weiterverwendet werden k\xf6nnen.\\n!!! WICHTIG: Die Zahlen m\xfcssen noch einmal mit int() in Zahlen verwandelt werden, weil bei der Validierung bloss geschaut wird, ob es m\xf6glich w\xe4re, diese in Zahlen umzuwandeln.\\n\\n- Dann habe ich eine neue Funktion \\"auswerten()\\" erstellt, die die Koordiaten liest und im Spielfeld sucht. Das gefundene Feld wird mit 0 markiert, was bei der \\"mache_spielfeld\\"-Funktion dazu f\xfchrt, dass das Feld leer ausgegeben wird.\\n\\n```py\\ndef auswerten(zeile, spalte):\\n    spielfeld[zeile][spalte] = 0\\n```\\n\\n!!! WICHTIG: Die Zahlen m\xfcssen an Variablen \xfcbergeben werden, die dann als \\"zeile\\" und \\"spalte\\" -Parameter an die Funktion \\"auswerten()\\" \xfcbergeben werden kann. Dies geschieht in \\"eingabe()\\".\\n\\n```py\\n    x, y = eingabe()\\n    auswerten(x, y)\\n```\\n\\n- Als letztes habe ich alle diese Funktionen in eine gesamte Funktion \\"play()\\" hineingeschrieben und diesen Vorgang solange das Spiel l\xe4uft (momentan unendlich lange) laufen lassen. Sp\xe4ter wurde dieser dann durch die Bedingungen \\"verloren()\\" und \\"gewonnen()\\" eingeschr\xe4nkt. (-> mein Game-Loop)\\n\\n### **Validierung:**\\n\\n- Ich habe mit Alice sehr viel besprochen. Bei mir waren Probleme beim Validieren aufgetreten, da ich die Werte falsch oder als String \xfcbergeben habe. Bei ihr wurde das Wort \\"True\\" \xfcbergeben. Beides konten wir jedoch beheben.\\n\\n```py\\ndef eingabe_validieren(zeile, spalte):\\n    try:\\n        zeile = int(zeile) - 1\\n        spalte = int(spalte) - 1\\n        return True\\n    except:\\n        print(\'Zeilen- und Spaltennummer m\xfcssen Zahlen sein!\')\\n        return False\\n```\\n\\n??? Aufgetauchte Fragen: Muss hier \'return True\' geschrieben werden? Wird hier zeile und spalte \xfcbergeben?\\n\\n- Sp\xe4ter habe ich dann die Funktion noch erg\xe4nzt, indem ich auch noch \xfcberpr\xfcft habe ob der eingegebene Wert \xfcberhaupt im Bereich des Spielfelds liegt:\\n\\n```py\\ndef eingabe_validieren(zeile, spalte):\\n    try:\\n        zeile = int(zeile) - 1\\n        spalte = int(spalte) - 1\\n        if zeile < 0 or zeile > 4:\\n            print(\'Zeile ist nicht im Feld\')\\n            return False\\n        if spalte < 0 or spalte > 4:\\n            print(\'Spalte ist nicht im Feld\')\\n            return False\\n        return True  # Notwendig? Ja, ewtas muss zur\xfcckgegeben werden\\n    except:\\n        print(\'Zeilen- und Spaltennummer m\xfcssen Zahlen sein!\')\\n        return False\\n```\\n\\n-Zum Abschluss der Validierung \xfcberpr\xfcfe ich noch, ob die Eingabe nicht nur valide, sondern auch erlaubt ist: mit der Funktion \\"feldauswahl_validieren()\\", die pr\xfcft, ob das Feld \xfcberhaupt einen Nachbar hat und somit ausgew\xe4hlt werden darf.\\n\\n```py\\ndef feldauswahl_validieren(zeile, spalte):\\n    zeile = int(zeile) - 1\\n    spalte = int(spalte) - 1\\n    if (spalte + 1) <= 4:\\n        if spielfeld[zeile][spalte] == spielfeld[zeile][spalte + 1]:\\n            return True\\n    if (spalte - 1) >= 0:\\n        if spielfeld[zeile][spalte] == spielfeld[zeile][spalte - 1]:\\n            return True\\n    if (zeile + 1) <= 4:\\n        if spielfeld[zeile][spalte] == spielfeld[zeile + 1][spalte]:\\n            return True\\n    if (zeile - 1) >= 0:\\n        if spielfeld[zeile][spalte] == spielfeld[zeile - 1][spalte]:\\n            return True\\n    print(\'Das ausgew\xe4hlte Feld muss Nachbaren haben\')\\n    return False\\n```\\n\\n### **Nachbarzellen kombinieren:**\\n\\n- Ich habe versucht den Floodfill-code so umzuwandeln, dass er in mein Spiel passt.\\n\\n??? Leider ist ein kleines Problem aufgetreten. Da ich die Zahl bereits vorher auf 0 gesetzt hatte, testet es nun, ob 0 die zu testende Zahl gleich ist wie 0.\\n\\n```py\\ndef nachbarfelder_l\xf6schen(x, y, vorherige_Zahl):\\n    if spielfeld[x][y] == vorherige_Zahl:  # Zahl ist ja bereits 0??\\n        spielfeld[x][y] = 0\\n        nachbarfelder_l\xf6schen(x, y + 1)  # rechts\\n        nachbarfelder_l\xf6schen(x, y - 1)  # links\\n        nachbarfelder_l\xf6schen(x + 1, y)  # unten\\n        nachbarfelder_l\xf6schen(x - 1, y)  # oben\\n```\\n\\n-Die Probleme habe ich behoben, in dem ich die vorige Funktion \\"auswerten()\\" nicht alleine gebraucht habe, sondern in die Funktion \\"nachbarfelder_l\xf6schen()\\" eingebaut und auf \\"auswerten()\\" umgetauft habe. Zus\xe4tzlich habe ich eine Zahl vorher \xfcbergeben, welche die Zahl in diesem Feld speichert und bei der rekursiven Auswerten-funktion benutzt werden kann. Damit es keine Fehler gibt, habe ich die Rahmenbedingung in den Code eingebaut.\\n-Sp\xe4ter habe ich dann die Funktion \\"auswerten()\\" erg\xe4nzt mit diesem flood-fill-Algorythmus, in der alle aneinanderliegenden Felder mit dem gleichen Wert auf 0 gesetzt werden. Die fertige auswerten-Funktion sieht nun so aus:\\n\\n```py\\ndef auswerten(x, y, vorherige_Zahl):\\n    # Rahmenbedingungen\\n    if x < 0 or x > 4:\\n        return False\\n    if y < 0 or y > 4:\\n        return False\\n    # Feld\xfcberpr\xfcfen\\n    # im Spielfeld die richtige Liste (zeile), dann richtige Position in Liste (spalte)\\n    if spielfeld[x][y] == vorherige_Zahl:\\n        spielfeld[x][y] = 0\\n        auswerten(x, y + 1, vorherige_Zahl)  # rechts\\n        auswerten(x, y - 1, vorherige_Zahl)  # links\\n        auswerten(x + 1, y, vorherige_Zahl)  # unten\\n        auswerten(x - 1, y, vorherige_Zahl)  # oben\\n```\\n\\n### **Felder auff\xfcllen:**\\n\\n- Die Funktion \\"felder_auff\xfcllen()\\" hat mir von allem die meisten Sorgen bereitet. Egal was ich versuchte, irgenwie ging nichts, wie ich es wollte und ich fang die Fehler einfach nicht. Es schrieb zuf\xe4llige Zahlen irgendwo, wo ich sie nicht wollte und zuwenige oder falsche Felder fielen nach unten. Zudem habe ich sie zu Beginn viel zu kompliziert geschrieben, indem ich Variablen f\xfcr die Koordinaten erstellt habe und durch alle Zellen durchiteriert habe, anstatt direkt die Variablen in eine Range-Schlaufe zu tun.\\n- Zwei grosse Fehler haben sich bei mir ergeben. Der Zeilenindex hatte die Bedingung >= 0 zu sein. Jedoch hiess das, dass er beim letzten Mal von 0 noch aus -1 stellte. Dies gab ein Fehler bei den Grenzen. Behoben habe ich ihn durch das Wegnehmen des Gleichzeichen - so konnte der Zeilenindex maximal auf 0 kommen. Der zweite grosse Fehler war, dass ich die Zahlen vertauscht haben und dann direkt eine zuf\xe4llige Zahl eingesetzt habe. Hatte es oberhalb der vertauschten Zahlen noch eine Zahl, die nach unten fallen sollte, war dies nicht mehr m\xf6glich, da keine 0 mehr vorhanden war. Dadurch musste ich zuerst die Zahl auf 0 stellen und erst ganz am Ende durch das Feld gehen und alle leeren Felder mit zuf\xe4lligen Zahlen bef\xfcllen.\\n\\nMein Endresultat:\\n\\n```py\\ndef felder_auff\xfcllen(x, y, vorherige_zahl):\\n    spielfeld[x][y] = vorherige_zahl * 2\\n    for zeile in range(4, 0, -1):\\n        for zelle in range(4, 0, -1):\\n            if spielfeld[zeile][zelle] == 0:\\n                zeilenindex = zeile\\n                while zeilenindex > 0 and spielfeld[zeilenindex][zelle] == 0:\\n                    zeilenindex = zeilenindex - 1\\n                spielfeld[zeile][zelle] = spielfeld[zeilenindex][zelle]\\n                spielfeld[zeilenindex][zelle] = 0\\n    for zeile in range(5):\\n        for zelle in range(5):\\n            if spielfeld[zeile][zelle] == 0:\\n                spielfeld[zeile][zelle] = random.choice([2, 4, 8])\\n```\\n\\n??? Eine Frage, die noch aufgetaucht ist: Wieso muss ich die letzten vier Zeilen mit range und den Koordinaten schreiben und kann nicht bloss durch die Zellen durchiterieren und die Zelle direkt vergleichen?\\n\\n```py\\nfor zeile in spielfeld:\\n    for zelle in zeile:\\n        if zelle == 0:\\n            zelle == random.choice([2, 4, 8])\\n```\\n\\n### **Gewonnen und verloren:**\\n\\n- Ganz am Schluss des Spiels habe ich noch eine Bedingung eingebaut, wann man gewonnen hat (wenn man die Zahl 256 erreicht hat) und wann man verloren hat (wenn man kein Feld mehr hat mit gleichwertigen Nachbaren).\\n\\n#### Gewonnen:\\n\\n- Die Funktion \\"gewonnen()\\" war relativ einfach. Ich musste bloss jedes Feld durchgehen und schauen, ob irgendeine Zelle den Wert 256 erreicht hat.\\n\\n```py\\ndef gewonnen():\\n    for zeile in spielfeld:\\n        for zelle in zeile:\\n            if zelle == 256:\\n                print(\'Yee, du hast gewonnen!\')\\n                return True\\n    return False\\n```\\n\\n#### Verloren:\\n\\n- Die Funktion \\"verloren()\\" war dagegen schon deutlich schwieriger zu machen. Ich musste dabei von jeder Zelle alle Nachbaren (oben, unten, links, rechts) \xfcberpr\xfcfen, ob sie den gleichen Wert haben. Zus\xe4tzlich muss ich vor der \xdcberpr\xfcfung aber auch schauen, ob das zu testende Feld \xfcberhaupt existiert, da es sonst einen Fehler gibt. Dies machte mir am Anfang noch Probleme. Ich habe dies gel\xf6st, indem ich die If-Bedingungen f\xfcr die \\"Nachbar\xfcberpr\xfcfung\\" in eine If-bedingung der \\"Existiert-feld-\xfcberpr\xfcfung\\" hineingesetzt habe.\\n\\n```py\\ndef verloren():\\n    for zeile in range(5):\\n        for zelle in range(5):\\n            if (zelle + 1) <= 4:\\n                if spielfeld[zeile][zelle] == spielfeld[zeile][zelle + 1]:\\n                    return False\\n            if (zelle - 1) >= 0:\\n                if spielfeld[zeile][zelle] == spielfeld[zeile][zelle - 1]:\\n                    return False\\n            if (zeile + 1) <= 4:\\n                if spielfeld[zeile][zelle] == spielfeld[zeile + 1][zelle]:\\n                    return False\\n            if (zeile - 1) >= 0:\\n                if spielfeld[zeile][zelle] == spielfeld[zeile - 1][zelle]:\\n                    return False\\n    print(\'Schade, du hast verloren!\')\\n    return True\\n```\\n\\n### **Zuf\xe4lliges Spielfeld generieren:**\\n\\n-Als Finish habe ich noch ein zuf\xe4lliges Spielfeld generiert, damit man nicht immer mit dem gleichen Spielfeld startet. Dies habe ich gemacht, indem ich am Anfang ein leeres Spielfeld generiert habe und dies dann mit zuf\xe4lligen Zahlen (2, 4, 8 oder 16) bef\xfcllt habe:\\n\\n```py\\ndef erstelle_zuf\xe4lliges_board():\\n    global spielfeld\\n    for zeile in range(5):\\n        for zelle in range(5):\\n            spielfeld[zeile].append(2**random.randint(1, 4))\\n```\\n\\nHier sind vor allem die aktuellen Codebl\xf6cke von mir drin, jedoch mit Beschreibung meines Vorgehens und dem \\"Endresultat\\"."},{"id":"/Numtrip_finaler_blog","metadata":{"permalink":"/EF_Informatik/Numtrip_finaler_blog","editUrl":"https://github.com/Liloubrandi/EF_Informatik/tree/main/blog/Numtrip_finaler_blog.md","source":"@site/blog/Numtrip_finaler_blog.md","title":"Numtrip_finaler_blog","description":"Finaler Blogbeitrag Numtrip","date":"2023-06-15T14:59:07.000Z","formattedDate":"15. Juni 2023","tags":[],"readingTime":3.78,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"Mein Weg zum Numtrip-Game","permalink":"/EF_Informatik/Numtrip_blog"},"nextItem":{"title":"Wiedereinstieg in Python","permalink":"/EF_Informatik/2022/08/26/Wiedereinstieg-in-Python"}},"content":"## **Finaler Blogbeitrag Numtrip**\\n\\n### Ziel des Spiels:\\n\\nMan soll ein Spielfeld mit (quadratischen) Felder mit jeweils einer Zahl haben, welches ausgegeben werden kann und f\xfcr den Benutzer sichtbar ist. Der Benutzer w\xe4hlt nun ein Feld seiner Wahl (solange es einen gleichwertigen Nachbar hat). Dieses Feld und alle gleichwertigen Nachbaren werden nun gel\xf6scht und an der Stelle des ausgew\xe4hlten Feldes steht nun der doppelte Wert des vorherigen Werts. Dann fallen alle nach unten (schliessen auf) falls unter ihnen noch ein leeres Feld ist und der Rest des Spielfelds wird mit zuf\xe4lligen Zahlen aufgef\xfcllt.\\n!!!Im Spiel kommen als Zahlen nur Zweierpotenzen vor(bei mir ohne 1). Das Ziel besteht dann darin, 256 zu erreichen in einem Feld, ohne vorher zu verlieren. Verlieren tut man, wenn man kein Feld mehr mit gleichwertigen Nachbaren hat.\\n\\nEin weiteres Ziel f\xfcr uns war auch, dass wir die gelernten Grundlagen nicht nur theoretisch beherrschen, sondern auch praktisch und verbunden miteinander.\\n\\n## Umsetzung des Spiels:\\n\\n- Voraussetzung: Man sollte Python 3.10.6 installiert haben. Man sollte zudem ein Programm heruntergeladen haben, welches Code ausf\xfchren kann.\\n\\n### Top-down-Entwurf mit meinen Funktionen:\\n\\n![Top-Down Numtrip](../docs/images/Top_down_Numtrip.jpg)\\n\\n### Der Flood-fill-Algorythmus:\\n\\nIch habe mich daf\xfcr entschieden, den Flood-fill-Algorhythmus kurz zu erl\xe4utern, da ich mich bereits im Pythonrepetition mit rekursiven Funktionen besch\xe4ftigt haben.  \\nDas Prinzip von rekursiven Funktionen ist, dass sich die Funktion selbst aufruft. Dadurch ensteht eine (zugegeben ziemlich komplexe) Verschachtelung der Ausf\xfchrungen, die in der Funktion get\xe4tigt werden. Zudem muss immer eine Abbruchbedingung formuliert werden, da sonst der Algorythmus unendlich lange weiterl\xe4uft.\\n\\n- Das schwerste am Schreiben einer rekursiven Funktion ist wohl, dass man im Kopf versucht zu \xfcberlegen wann die Funktion sich selbst aufruft, damit die Verschachtelung an der richtigen Stelle geschieht.\\n\\nIch brauchte eine rekursive Funktion beim L\xf6schen der Felder mit dem gleichen Wert. In der Funktion sollte gepr\xfcft werden, ob das anliegende Feld der gleiche Wert hat und wenn ja, ob das anliegende Feld dieses anliegenden Feldes auch den gleichen Wert hat. Um diese \xdcberpr\xfcfung eben auch von den anliegenden Felder aus zu machen, muss sich die Funktion selbst aufrufen -> rekursive Funktion.\\nMein Flood-fil-Algorythmus im Spiel sieht so aus (mit Rahmenbedingungen, damit es nicht ausserhalb des Feldes \xfcberpr\xfcft):\\n\\n```py\\ndef auswerten(x, y, vorherige_Zahl):\\n    # Rahmenbedingungen\\n    if x < 0 or x > 4:\\n        return False\\n    if y < 0 or y > 4:\\n        return False\\n    # Feld\xfcberpr\xfcfen\\n    # im Spielfeld die richtige Liste (zeile), dann richtige Position in Liste (spalte)\\n    if spielfeld[x][y] == vorherige_Zahl:\\n        spielfeld[x][y] = 0\\n        auswerten(x, y + 1, vorherige_Zahl)  # rechts\\n        auswerten(x, y - 1, vorherige_Zahl)  # links\\n        auswerten(x + 1, y, vorherige_Zahl)  # unten\\n        auswerten(x - 1, y, vorherige_Zahl)  # oben\\n```\\n\\n### Meine gr\xf6ssten Herausvorderungen:\\n\\nAm meisten M\xfche hatte ich mit der Funktion \\"felder_auff\xfcllen()\\", in der die Felder \\"hinunterfallen\\", wenn unter ihnen ein leeres Feld ist. Dann sollte das Spielfeld zuf\xe4llig aufgef\xfcllt werden in allen Zellen, die noch leer sind.  \\nIch hatte immer pl\xf6tzlich nach etwa 20 Z\xfcgen ein leeres Feld und ich wusste nicht woher. Ich habe einfach gedacht, dass ich vergessen habe die restlichen Felder aufzuf\xfcllen und nur den Feldern, die ausgetauscht wurden einen neuen Wert zugwiesen haben. Jedoch habe ich nicht gemerkt, dass auch vorher beim \\"Herunterfallen\\" einen Fehler passiert ist. Hatte es n\xe4mlich z.B. zwei Zahlen oberhalb eines leeren Feldes, so habe ich die untere mit der leeren getauscht, jedoch dann eine Zufallszahl hingesetzt bevor die zweite Zahl auch noch \\"hinunterfallen\\" konnte.  \\nEigentlich nur ein kleiner Fehler, der jedoch sehr lange unentdeckt blieb und mich verzweifeln liess.\\n\\n```py\\nif spielfeld[zeile][zelle] == 0:\\n    zeilenindex = zeile\\n    while zeilenindex > 0 and spielfeld[zeilenindex][zelle] == 0:\\n        zeilenindex = zeilenindex - 1\\n    spielfeld[zeile][zelle] = spielfeld[zeilenindex][zelle]\\n    spielfeld[zeilenindex][zelle] = random.choice([2, 4, 8]) #-> FEHLER! Zuerst sollte da auf 0 gesetzt werden.\\n```\\n\\n### Tipps f\xfcr andere Sch\xfcler:\\n\\n- Beginne immer bei 0 beim z\xe4hlen!! Jedoch ist es f\xfcr den Benutzer einfacher bei 1 zu beginnen. Also lasse den Benutzer beim Eingeben von Zahlen bei 1 starten, vergesse jedoch nicht, dann beim Auswerten der Eingabe die Zahl noch um eins zu verkleinern.\\n- \xdcberpr\xfcfe, ob die Grenzen stimmen! Will ich x >= 0 oder nur x > 0 schreiben, dies macht einen Unterschied und kann den ganzen Code ver\xe4ndern. -> Auch da wieder: Man beginnt bei 0 mit z\xe4hlen!\\n- \xdcberlege dir vorher genau einen Plan (eventuell sogar mit Skizze) und kommentiere komplexe Funktionen oder Zeilen, damit du auch sp\xe4ter noch verstehst, was gemacht wurde.\\n- Bleibe dran! Manchmal geht es ewigs, bis man einen Fehler findet oder bis etwas so funktioniert, wie man es will. Dies kann nervenraubend sein, aber du schaffst das!"},{"id":"/2022/08/26/Wiedereinstieg-in-Python","metadata":{"permalink":"/EF_Informatik/2022/08/26/Wiedereinstieg-in-Python","editUrl":"https://github.com/Liloubrandi/EF_Informatik/tree/main/blog/2022-08-26-Wiedereinstieg-in-Python.md","source":"@site/blog/2022-08-26-Wiedereinstieg-in-Python.md","title":"Wiedereinstieg in Python","description":"---","date":"2022-08-26T00:00:00.000Z","formattedDate":"26. August 2022","tags":[],"readingTime":1.305,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"Numtrip_finaler_blog","permalink":"/EF_Informatik/Numtrip_finaler_blog"}},"content":"---\\n\\n### Mein pers\xf6nlicher Einstieg:\\n\\nIch habe vorher noch nie mit der Bibliothek \'turtle\' gearbeitet, deshalb kam mir (ausser viellicht die Struktur) fast nichts bekannt vor. Es war jedoch sehr selbsterkl\xe4rend und deswegen konnte ich gut den Anschluss finden.  \\n.\\n\\n### Meine Fehler:\\n\\nObwohl ich diesen Fehler bereits begangen habe, habe ich immer vergessen die **Anf\xfchrungszeichen** bei den **Farben** in der Klammer hinzuzuf\xfcgen.\\n\\n```py\\nfrom turtle import *\\n\\npencolor(\'red\')\\npensize(5)\\nforward(30)\\nright(90)\\n```\\n\\nWenn man in einem If etwas mitem einem Gleichzeichen vergleichen will, muss man immer ein Doppelgleich (==) setzen. Ein = w\xe4re eine Zuweisung bei einer Variable.\\n\\n```py\\nif i == 3:\\n    sechseck(100-10*i,\'green\')\\n#Dies ist nur ein Ausschnitt aus Codeblock\\n```\\n\\nIch habe erst nach dem dritten Mal lesen gemerkt, dass ich bei der Aufgabe mit der Stadt nicht \'pencolor(choice([1,3,5,7,9]))\' schreiben muss, sondern die Farbnahmen auflisten muss haha:/  \\n.\\n\\n### Das war mir besonders neu:\\n\\nDas man sequenzieren kann mit \'for i in range(n)\'\\n\\n```py\\nfrom turtle import *\\n\\nfor i in range(4))\\n    left(90)\\n    forward(80)\\n```\\n\\n.\\n\\n### Fragen, die aufgetaucht sind zu \xdcbungen:\\n\\nKann man Kreise (circle(x,y)) nur nach links machen oder auch der andere Weg?\\n\\n```py\\nblume()\\nright(40)\\npencolor(\'black\')\\npensize(2)\\nfor i in range(20):\\n    forward(10)\\n    right(2)\\n#nicht richtiges Codebeispiel, nur Auschnitt aus dem Code mit meiner L\xf6sung (anstatt mit den circle-Funktionsaufruf)\\n```\\n\\nKann Python auch hochrechnen mit Hochzeichen (^) anstatt nur mit x \\\\* x?\\n\\n```py\\nleft(135)\\n    forward(sqrt(size * size + size * size))\\n    left(90)\\n    forward(sqrt(size * size + size * size)/2)\\n#nur Ausschnitt aus Codeblock\\n```\\n\\nWie mache ich beim Ratespiel die M\xf6glichkeit das Ganze abzubrechen?"}]}')}}]);
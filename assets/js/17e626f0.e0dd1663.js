"use strict";(self.webpackChunkef_website_template=self.webpackChunkef_website_template||[]).push([[551],{3905:(e,n,r)=>{r.d(n,{Zo:()=>d,kt:()=>h});var t=r(7294);function i(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function a(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function l(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?a(Object(r),!0).forEach((function(n){i(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function s(e,n){if(null==e)return{};var r,t,i=function(e,n){if(null==e)return{};var r,t,i={},a=Object.keys(e);for(t=0;t<a.length;t++)r=a[t],n.indexOf(r)>=0||(i[r]=e[r]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(t=0;t<a.length;t++)r=a[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var u=t.createContext({}),o=function(e){var n=t.useContext(u),r=n;return e&&(r="function"==typeof e?e(n):l(l({},n),e)),r},d=function(e){var n=o(e.components);return t.createElement(u.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},p=t.forwardRef((function(e,n){var r=e.components,i=e.mdxType,a=e.originalType,u=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=o(r),h=i,m=p["".concat(u,".").concat(h)]||p[h]||c[h]||a;return r?t.createElement(m,l(l({ref:n},d),{},{components:r})):t.createElement(m,l({ref:n},d))}));function h(e,n){var r=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=r.length,l=new Array(a);l[0]=p;var s={};for(var u in n)hasOwnProperty.call(n,u)&&(s[u]=n[u]);s.originalType=e,s.mdxType="string"==typeof e?e:i,l[1]=s;for(var o=2;o<a;o++)l[o]=r[o];return t.createElement.apply(null,l)}return t.createElement.apply(null,r)}p.displayName="MDXCreateElement"},2342:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>u,contentTitle:()=>l,default:()=>c,frontMatter:()=>a,metadata:()=>s,toc:()=>o});var t=r(7462),i=(r(7294),r(3905));const a={},l="Mein Weg zum Numtrip-Game",s={permalink:"/EF_Informatik/Numtrip_blog",editUrl:"https://github.com/Liloubrandi/EF_Informatik/tree/main/blog/Numtrip_blog.md",source:"@site/blog/Numtrip_blog.md",title:"Mein Weg zum Numtrip-Game",description:"Eingabe und Start:",date:"2023-01-23T12:38:06.000Z",formattedDate:"23. Januar 2023",tags:[],readingTime:3.135,hasTruncateMarker:!1,authors:[],frontMatter:{},nextItem:{title:"Wiedereinstieg in Python",permalink:"/EF_Informatik/2022/08/26/Wiedereinstieg-in-Python"}},u={authorsImageUrls:[]},o=[{value:"<strong>Eingabe und Start:</strong>",id:"eingabe-und-start",level:3},{value:"<strong>Validierung: (2.12.22)</strong>",id:"validierung-21222",level:3},{value:"<strong>Nachbarzellen kombinieren</strong>",id:"nachbarzellen-kombinieren",level:3}],d={toc:o};function c(e){let{components:n,...r}=e;return(0,i.kt)("wrapper",(0,t.Z)({},d,r,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h3",{id:"eingabe-und-start"},(0,i.kt)("strong",{parentName:"h3"},"Eingabe und Start:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'Als erstes musste ich irgendwie nach einer Eingabe nach Zeilen- und Spaltennummer fragen. Daf\xfcr habe ich eine Funktion "eingabe()" geschrieben, in der ich nach den beiden Zahlen frage. Die Eingabe wird noch validiert.')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-py"},"def eingabe():\n    zeile = input('Gib eine Zeilennummer zwischen 1 und 6 ein:')\n    spalte = input('Gib eine Spaltennummer zwischen 1 und 6 ein:')\n    eingabe_validieren(zeile, spalte)\n    return (zeile, spalte)\n")),(0,i.kt)("p",null,"Obiger Code funktioniert so noch nicht genau, war bloss erster Versuch, L\xf6sung weiter unten im Blog bei Validierung."),(0,i.kt)("p",null,"!!! WICHTIG: Ich muss die Zahlen zur\xfcckgeben, damit sie weiterverwendet werden k\xf6nnen."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'Dann habe ich eine neue Funktion "auswerten()" erstellt, die die Koordiaten liest und im Spielfeld sucht. Das gefundene Feld wird mit 0 markiert, was bei der "mache_spielfeld"-Funktion dazu f\xfchrt, dass das Feld leer ausgegeben wird.')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-py"},"def auswerten(zeile, spalte):\n    spielfeld[zeile][spalte] = 0\n")),(0,i.kt)("p",null,'!!! WICHTIG: Die Zahlen m\xfcssen an Variablen \xfcbergeben werden, die dann als zeile und spalte Parameter an die Funktion "auswerten()" \xfcbergeben werden kann. Dies geschieht in eingabe_validieren()"'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-py"},"    x, y = eingabe()\n    auswerten(x, y)\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'Als letztes habe ich alle diese Funktionen in eine gesamte Funktion "play()" hineingeschrieben und diesen Vorgang solange das Spiel l\xe4uft (momentan unendlich lange) laufen lassen.')),(0,i.kt)("h3",{id:"validierung-21222"},(0,i.kt)("strong",{parentName:"h3"},"Validierung: (2.12.22)")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'Ich habe mit Alice sehr viel besprochen. Bei mir waren Probleme beim Validieren aufgetreten, da ich die Werte falsch oder als String \xfcbergeben habe. Bei ihr wurde das Wort "True" \xfcbergeben. Beides konten wir jedoch beheben.')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-py"},"def eingabe_validieren(zeile, spalte):\n    try:\n        zeile = int(zeile) - 1\n        spalte = int(spalte) - 1\n        return True\n    except:\n        print('Zeilen- und Spaltennummer m\xfcssen Zahlen sein!')\n        return False\n")),(0,i.kt)("p",null,"??? Aufgetauchte Fragen: Muss hier 'return True' geschrieben werden? Wird hier zeile und spalte \xfcbergeben?"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-py"},"def eingabe():\n    zeile = \" \"\n    spalte = \" \"\n    while not eingabe_validieren(zeile, spalte):\n        zeile = input('Gib eine Zeilennummer zwischen 1 und 6 ein:')\n        spalte = input('Gib eine Spaltennummer zwischen 1 und 6 ein:')\n    return (int(zeile), int(spalte))\n")),(0,i.kt)("p",null,"!!! WICHTIG: Die Zahlen m\xfcssen noch einmal mit int() in Zahlen verwandelt werden, weil bei der Validierung bloss geschaut wird, ob es m\xf6glich w\xe4re, diese in Zahlen umzuwandeln."),(0,i.kt)("h3",{id:"nachbarzellen-kombinieren"},(0,i.kt)("strong",{parentName:"h3"},"Nachbarzellen kombinieren")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Ich habe versucht den Floodfill-code so umzuwandeln, dass er in mein Spiel passt.")),(0,i.kt)("p",null,"??? Leider ist ein kleines Problem aufgetreten. Da ich die Zahl bereits vorher auf 0 gesetzt hatte und es also testet, ob diese Zahl (also 0) eine 2 ist - was ja nie der Fall sein wird."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-py"},"def nachbarfelder_l\xf6schen(x, y, vorherige_Zahl):\n    if spielfeld[x][y] == vorherige_Zahl:  # Zahl ist ja bereits 0??\n        spielfeld[x][y] = 0\n        nachbarfelder_l\xf6schen(x, y + 1)  # rechts\n        nachbarfelder_l\xf6schen(x, y - 1)  # links\n        nachbarfelder_l\xf6schen(x + 1, y)  # unten\n        nachbarfelder_l\xf6schen(x - 1, y)  # oben\n")),(0,i.kt)("p",null,"???Ausserdem wird nur die Zahl 2 getestet und nicht die Zahl, die vorher im Kasten stand - ich weiss nicht wie ich diese \xfcbergeben soll."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-py"},"nachbarfelder_l\xf6schen(zeile, spalte, 2)\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'Die Probleme habe ich nun behoben, indem ich die Funktion auswerten ganz weggenommen habe (und somit die Zahl erst im "nachbarfelder_kombinieren" auf 0 gesetzt wird.) und die Funktion "nachbarfelder_komninieren" als Ganzes in "auswerten()" umgewandelt habe. Zus\xe4tzlich habe ich eine Zahl vorher \xfcbergeben, welche die Zahl in diesem Feld speichert und bei der rekursiven Auswerten-funktion benutzt werden kann. Damit es keine Fehler gibt, habe ich die Rahmenbedingung in den Code eingebaut.')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-py"},"def auswerten(x, y, vorherige_Zahl):\n    # Rahmenbedingungen\n    if x < 0 or x > 4:\n        return False\n    if y < 0 or y > 4:\n        return False\n    # Feld\xfcberpr\xfcfen\n    # im Spielfeld die richtige Liste (zeile), dann richtige Position in Liste (spalte)\n    if spielfeld[x][y] == vorherige_Zahl:\n        spielfeld[x][y] = 0\n        auswerten(x, y + 1, vorherige_Zahl)  # rechts\n        auswerten(x, y - 1, vorherige_Zahl)  # links\n        auswerten(x + 1, y, vorherige_Zahl)  # unten\n        auswerten(x - 1, y, vorherige_Zahl)  # oben\n")))}c.isMDXComponent=!0}}]);
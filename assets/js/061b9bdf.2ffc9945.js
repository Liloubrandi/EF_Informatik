"use strict";(self.webpackChunkef_website_template=self.webpackChunkef_website_template||[]).push([[846],{7384:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"/Numtrip_blog","metadata":{"permalink":"/EF_Informatik/Numtrip_blog","editUrl":"https://github.com/Liloubrandi/EF_Informatik/tree/main/blog/Numtrip_blog.md","source":"@site/blog/Numtrip_blog.md","title":"Mein Weg zum Numtrip-Game","description":"Eingabe und Start:","date":"2023-01-23T21:20:54.000Z","formattedDate":"23. Januar 2023","tags":[],"readingTime":7.155,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"nextItem":{"title":"Wiedereinstieg in Python","permalink":"/EF_Informatik/2022/08/26/Wiedereinstieg-in-Python"}},"content":"### **Eingabe und Start:**\\n\\n- Als erstes musste ich irgendwie nach einer Eingabe nach Zeilen- und Spaltennummer fragen. Daf\xfcr habe ich eine Funktion \\"eingabe()\\" geschrieben, in der ich nach den beiden Zahlen frage. Die Eingabe wird noch validiert. Damit ich nun so lange frage, bis die Eingabe valide ist, verwende ich eine while-Schlaufe.\\n\\n```py\\ndef eingabe():\\n    # invalide Eingaben, damit der Code unter while \xfcberhaupt durchgef\xfchrt wird.\\n    valid = False\\n    while not valid:\\n        zeile = input(\'Gib eine Zeilennummer zwischen 1 und 5 ein:\')\\n        spalte = input(\'Gib eine Spaltennummer zwischen 1 und 5 ein:\')\\n        if eingabe_validieren(zeile, spalte) and feldauswahl_validieren(zeile, spalte):\\n            valid = True\\n    # noch einmal, weil bei eingabe_validieren \xfcberpr\xfcft es nur\\n    return (int(zeile) - 1, int(spalte) - 1)\\n```\\n\\n!!! WICHTIG: Ich muss die Zahlen zur\xfcckgeben, damit sie weiterverwendet werden k\xf6nnen.\\n!!! WICHTIG: Die Zahlen m\xfcssen noch einmal mit int() in Zahlen verwandelt werden, weil bei der Validierung bloss geschaut wird, ob es m\xf6glich w\xe4re, diese in Zahlen umzuwandeln.\\n\\n- Dann habe ich eine neue Funktion \\"auswerten()\\" erstellt, die die Koordiaten liest und im Spielfeld sucht. Das gefundene Feld wird mit 0 markiert, was bei der \\"mache_spielfeld\\"-Funktion dazu f\xfchrt, dass das Feld leer ausgegeben wird.\\n\\n```py\\ndef auswerten(zeile, spalte):\\n    spielfeld[zeile][spalte] = 0\\n```\\n\\n!!! WICHTIG: Die Zahlen m\xfcssen an Variablen \xfcbergeben werden, die dann als \\"zeile\\" und \\"spalte\\" -Parameter an die Funktion \\"auswerten()\\" \xfcbergeben werden kann. Dies geschieht in \\"eingabe()\\".\\n\\n```py\\n    x, y = eingabe()\\n    auswerten(x, y)\\n```\\n\\n- Als letztes habe ich alle diese Funktionen in eine gesamte Funktion \\"play()\\" hineingeschrieben und diesen Vorgang solange das Spiel l\xe4uft (momentan unendlich lange) laufen lassen. Sp\xe4ter wurde dieser dann durch die Bedingungen \\"verloren()\\" und \\"gewonnen()\\" eingeschr\xe4nkt. (-> mein Game-Loop)\\n\\n### **Validierung:**\\n\\n- Ich habe mit Alice sehr viel besprochen. Bei mir waren Probleme beim Validieren aufgetreten, da ich die Werte falsch oder als String \xfcbergeben habe. Bei ihr wurde das Wort \\"True\\" \xfcbergeben. Beides konten wir jedoch beheben.\\n\\n```py\\ndef eingabe_validieren(zeile, spalte):\\n    try:\\n        zeile = int(zeile) - 1\\n        spalte = int(spalte) - 1\\n        return True\\n    except:\\n        print(\'Zeilen- und Spaltennummer m\xfcssen Zahlen sein!\')\\n        return False\\n```\\n\\n??? Aufgetauchte Fragen: Muss hier \'return True\' geschrieben werden? Wird hier zeile und spalte \xfcbergeben?\\n\\n- Sp\xe4ter habe ich dann die Funktion noch erg\xe4nzt, indem ich auch noch \xfcberpr\xfcft habe ob der eingegebene Wert \xfcberhaupt im Bereich des Spielfelds liegt:\\n\\n```py\\ndef eingabe_validieren(zeile, spalte):\\n    try:\\n        zeile = int(zeile) - 1\\n        spalte = int(spalte) - 1\\n        if zeile < 0 or zeile > 4:\\n            print(\'Zeile ist nicht im Feld\')\\n            return False\\n        if spalte < 0 or spalte > 4:\\n            print(\'Spalte ist nicht im Feld\')\\n            return False\\n        return True  # Notwendig? Ja, ewtas muss zur\xfcckgegeben werden\\n    except:\\n        print(\'Zeilen- und Spaltennummer m\xfcssen Zahlen sein!\')\\n        return False\\n```\\n\\n-Zum Abschluss der Validierung \xfcberpr\xfcfe ich noch, ob die Eingabe nicht nur valide, sondern auch erlaubt ist: mit der Funktion \\"feldauswahl_validieren()\\", die pr\xfcft, ob das Feld \xfcberhaupt einen Nachbar hat und somit ausgew\xe4hlt werden darf.\\n\\n```py\\ndef feldauswahl_validieren(zeile, spalte):\\n    zeile = int(zeile) - 1\\n    spalte = int(spalte) - 1\\n    if (spalte + 1) <= 4:\\n        if spielfeld[zeile][spalte] == spielfeld[zeile][spalte + 1]:\\n            return True\\n    if (spalte - 1) >= 0:\\n        if spielfeld[zeile][spalte] == spielfeld[zeile][spalte - 1]:\\n            return True\\n    if (zeile + 1) <= 4:\\n        if spielfeld[zeile][spalte] == spielfeld[zeile + 1][spalte]:\\n            return True\\n    if (zeile - 1) >= 0:\\n        if spielfeld[zeile][spalte] == spielfeld[zeile - 1][spalte]:\\n            return True\\n    print(\'Das ausgew\xe4hlte Feld muss Nachbaren haben\')\\n    return False\\n```\\n\\n### **Nachbarzellen kombinieren:**\\n\\n- Ich habe versucht den Floodfill-code so umzuwandeln, dass er in mein Spiel passt.\\n\\n??? Leider ist ein kleines Problem aufgetreten. Da ich die Zahl bereits vorher auf 0 gesetzt hatte, testet es nun, ob 0 die zu testende Zahl gleich ist wie 0.\\n\\n```py\\ndef nachbarfelder_l\xf6schen(x, y, vorherige_Zahl):\\n    if spielfeld[x][y] == vorherige_Zahl:  # Zahl ist ja bereits 0??\\n        spielfeld[x][y] = 0\\n        nachbarfelder_l\xf6schen(x, y + 1)  # rechts\\n        nachbarfelder_l\xf6schen(x, y - 1)  # links\\n        nachbarfelder_l\xf6schen(x + 1, y)  # unten\\n        nachbarfelder_l\xf6schen(x - 1, y)  # oben\\n```\\n\\n-Die Probleme habe ich behoben, in dem ich die vorige Funktion \\"auswerten()\\" nicht alleine gebraucht habe, sondern in die Funktion \\"nachbarfelder_l\xf6schen()\\" eingebaut und auf \\"auswerten()\\" umgetauft habe. Zus\xe4tzlich habe ich eine Zahl vorher \xfcbergeben, welche die Zahl in diesem Feld speichert und bei der rekursiven Auswerten-funktion benutzt werden kann. Damit es keine Fehler gibt, habe ich die Rahmenbedingung in den Code eingebaut.\\n-Sp\xe4ter habe ich dann die Funktion \\"auswerten()\\" erg\xe4nzt mit diesem flood-fill-Algorythmus, in der alle aneinanderliegenden Felder mit dem gleichen Wert auf 0 gesetzt werden. Die fertige auswerten-Funktion sieht nun so aus:\\n\\n```py\\ndef auswerten(x, y, vorherige_Zahl):\\n    # Rahmenbedingungen\\n    if x < 0 or x > 4:\\n        return False\\n    if y < 0 or y > 4:\\n        return False\\n    # Feld\xfcberpr\xfcfen\\n    # im Spielfeld die richtige Liste (zeile), dann richtige Position in Liste (spalte)\\n    if spielfeld[x][y] == vorherige_Zahl:\\n        spielfeld[x][y] = 0\\n        auswerten(x, y + 1, vorherige_Zahl)  # rechts\\n        auswerten(x, y - 1, vorherige_Zahl)  # links\\n        auswerten(x + 1, y, vorherige_Zahl)  # unten\\n        auswerten(x - 1, y, vorherige_Zahl)  # oben\\n```\\n\\n### **Felder auff\xfcllen:**\\n\\n- Die Funktion \\"felder_auff\xfcllen()\\" hat mir von allem die meisten Sorgen bereitet. Egal was ich versuchte, irgenwie ging nichts, wie ich es wollte und ich fang die Fehler einfach nicht. Es schrieb zuf\xe4llige Zahlen irgendwo, wo ich sie nicht wollte und zuwenige oder falsche Felder fielen nach unten. Zudem habe ich sie zu Beginn viel zu kompliziert geschrieben, indem ich Variablen f\xfcr die Koordinaten erstellt habe und durch alle Zellen durchiteriert habe, anstatt direkt die Variablen in eine Range-Schlaufe zu tun.\\n- Zwei grosse Fehler haben sich bei mir ergeben. Der Zeilenindex hatte die Bedingung >= 0 zu sein. Jedoch hiess das, dass er beim letzten Mal von 0 noch aus -1 stellte. Dies gab ein Fehler bei den Grenzen. Behoben habe ich ihn durch das Wegnehmen des Gleichzeichen - so konnte der Zeilenindex maximal auf 0 kommen. Der zweite grosse Fehler war, dass ich die Zahlen vertauscht haben und dann direkt eine zuf\xe4llige Zahl eingesetzt habe. Hatte es oberhalb der vertauschten Zahlen noch eine Zahl, die nach unten fallen sollte, war dies nicht mehr m\xf6glich, da keine 0 mehr vorhanden war. Dadurch musste ich zuerst die Zahl auf 0 stellen und erst ganz am Ende durch das Feld gehen und alle leeren Felder mit zuf\xe4lligen Zahlen bef\xfcllen.\\n\\nMein Endresultat:\\n\\n```py\\ndef felder_auff\xfcllen(x, y, vorherige_zahl):\\n    spielfeld[x][y] = vorherige_zahl * 2\\n    for zeile in range(4, 0, -1):\\n        for zelle in range(4, 0, -1):\\n            if spielfeld[zeile][zelle] == 0:\\n                zeilenindex = zeile\\n                while zeilenindex > 0 and spielfeld[zeilenindex][zelle] == 0:\\n                    zeilenindex = zeilenindex - 1\\n                spielfeld[zeile][zelle] = spielfeld[zeilenindex][zelle]\\n                spielfeld[zeilenindex][zelle] = 0\\n    for zeile in range(5):\\n        for zelle in range(5):\\n            if spielfeld[zeile][zelle] == 0:\\n                spielfeld[zeile][zelle] = random.choice([2, 4, 8])\\n```\\n\\n??? Eine Frage, die noch aufgetaucht ist: Wieso muss ich die letzten vier Zeilen mit range und den Koordinaten schreiben und kann nicht bloss durch die Zellen durchiterieren und die Zelle direkt vergleichen?\\n\\n```py\\nfor zeile in spielfeld:\\n    for zelle in zeile:\\n        if zelle == 0:\\n            zelle == random.choice([2, 4, 8])\\n```\\n\\n### **Gewonnen und verloren:**\\n\\n- Ganz am Schluss des Spiels habe ich noch eine Bedingung eingebaut, wann man gewonnen hat (wenn man die Zahl 256 erreicht hat) und wann man verloren hat (wenn man kein Feld mehr hat mit gleichwertigen Nachbaren).\\n\\n#### Gewonnen:\\n\\n- Die Funktion \\"gewonnen()\\" war relativ einfach. Ich musste bloss jedes Feld durchgehen und schauen, ob irgendeine Zelle den Wert 256 erreicht hat.\\n\\n```py\\ndef gewonnen():\\n    for zeile in spielfeld:\\n        for zelle in zeile:\\n            if zelle == 256:\\n                print(\'Yee, du hast gewonnen!\')\\n                return True\\n    return False\\n```\\n\\n#### Verloren:\\n\\n- Die Funktion \\"verloren()\\" war dagegen schon deutlich schwieriger zu machen. Ich musste dabei von jeder Zelle alle Nachbaren (oben, unten, links, rechts) \xfcberpr\xfcfen, ob sie den gleichen Wert haben. Zus\xe4tzlich muss ich vor der \xdcberpr\xfcfung aber auch schauen, ob das zu testende Feld \xfcberhaupt existiert, da es sonst einen Fehler gibt. Dies machte mir am Anfang noch Probleme. Ich habe dies gel\xf6st, indem ich die If-Bedingungen f\xfcr die \\"Nachbar\xfcberpr\xfcfung\\" in eine If-bedingung der \\"Existiert-feld-\xfcberpr\xfcfung\\" hineingesetzt habe.\\n\\n```py\\ndef verloren():\\n    ort_in_zeile = 0\\n    for zeile in spielfeld:\\n        ort_in_zelle = 0\\n        for zelle in zeile:\\n            if (ort_in_zelle + 1) <= 4:\\n                if zelle == spielfeld[ort_in_zeile][ort_in_zelle + 1]:\\n                    return False\\n            if (ort_in_zelle - 1) >= 0:\\n                if zelle == spielfeld[ort_in_zeile][ort_in_zelle - 1]:\\n                    return False\\n            if (ort_in_zeile + 1) <= 4:\\n                if zelle == spielfeld[ort_in_zeile + 1][ort_in_zelle]:\\n                    return False\\n            if (ort_in_zeile - 1) >= 0:\\n                if zelle == spielfeld[ort_in_zeile - 1][ort_in_zelle]:\\n                    return False\\n            ort_in_zelle = ort_in_zelle + 1\\n        ort_in_zeile = ort_in_zeile + 1\\n    print(\'Schade, du hast verloren!\')\\n    return True\\n```\\n\\nHier sind vor allem die aktuellen Codebl\xf6cke von mir drin, jedoch mit Beschreibung meines Vorgehens und dem \\"Endresultat\\"."},{"id":"/2022/08/26/Wiedereinstieg-in-Python","metadata":{"permalink":"/EF_Informatik/2022/08/26/Wiedereinstieg-in-Python","editUrl":"https://github.com/Liloubrandi/EF_Informatik/tree/main/blog/2022-08-26-Wiedereinstieg-in-Python.md","source":"@site/blog/2022-08-26-Wiedereinstieg-in-Python.md","title":"Wiedereinstieg in Python","description":"---","date":"2022-08-26T00:00:00.000Z","formattedDate":"26. August 2022","tags":[],"readingTime":1.305,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"Mein Weg zum Numtrip-Game","permalink":"/EF_Informatik/Numtrip_blog"}},"content":"---\\n\\n### Mein pers\xf6nlicher Einstieg:\\n\\nIch habe vorher noch nie mit der Bibliothek \'turtle\' gearbeitet, deshalb kam mir (ausser viellicht die Struktur) fast nichts bekannt vor. Es war jedoch sehr selbsterkl\xe4rend und deswegen konnte ich gut den Anschluss finden.  \\n.\\n\\n### Meine Fehler:\\n\\nObwohl ich diesen Fehler bereits begangen habe, habe ich immer vergessen die **Anf\xfchrungszeichen** bei den **Farben** in der Klammer hinzuzuf\xfcgen.\\n\\n```py\\nfrom turtle import *\\n\\npencolor(\'red\')\\npensize(5)\\nforward(30)\\nright(90)\\n```\\n\\nWenn man in einem If etwas mitem einem Gleichzeichen vergleichen will, muss man immer ein Doppelgleich (==) setzen. Ein = w\xe4re eine Zuweisung bei einer Variable.\\n\\n```py\\nif i == 3:\\n    sechseck(100-10*i,\'green\')\\n#Dies ist nur ein Ausschnitt aus Codeblock\\n```\\n\\nIch habe erst nach dem dritten Mal lesen gemerkt, dass ich bei der Aufgabe mit der Stadt nicht \'pencolor(choice([1,3,5,7,9]))\' schreiben muss, sondern die Farbnahmen auflisten muss haha:/  \\n.\\n\\n### Das war mir besonders neu:\\n\\nDas man sequenzieren kann mit \'for i in range(n)\'\\n\\n```py\\nfrom turtle import *\\n\\nfor i in range(4))\\n    left(90)\\n    forward(80)\\n```\\n\\n.\\n\\n### Fragen, die aufgetaucht sind zu \xdcbungen:\\n\\nKann man Kreise (circle(x,y)) nur nach links machen oder auch der andere Weg?\\n\\n```py\\nblume()\\nright(40)\\npencolor(\'black\')\\npensize(2)\\nfor i in range(20):\\n    forward(10)\\n    right(2)\\n#nicht richtiges Codebeispiel, nur Auschnitt aus dem Code mit meiner L\xf6sung (anstatt mit den circle-Funktionsaufruf)\\n```\\n\\nKann Python auch hochrechnen mit Hochzeichen (^) anstatt nur mit x \\\\* x?\\n\\n```py\\nleft(135)\\n    forward(sqrt(size * size + size * size))\\n    left(90)\\n    forward(sqrt(size * size + size * size)/2)\\n#nur Ausschnitt aus Codeblock\\n```\\n\\nWie mache ich beim Ratespiel die M\xf6glichkeit das Ganze abzubrechen?"}]}')}}]);